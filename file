from collections import deque

# Breadth-First Search algorithm
def bfs(graph, start, goal):
    queue = deque([(start, [start])])

    while queue:
        current_node, path = queue.popleft()
        if current_node == goal:
            return path
        for neighbor in graph[current_node]:
            if neighbor not in path:
                queue.append((neighbor, path + [neighbor]))

    return []

# Example usage:
graph = {}
n = int(input("Enter the number of nodes: "))
print("Enter edges in the format 'node1 node2'")
for _ in range(n):
    node1, node2 = input().split()
    if node1 not in graph:
        graph[node1] = []
    if node2 not in graph:
        graph[node2] = []
    graph[node1].append(node2)
    graph[node2].append(node1)

start_node = input("Enter the start node: ")
goal_node = input("Enter the goal node: ")

print("\nStarting from", start_node)
print("Searching for", goal_node)

path = bfs(graph, start_node, goal_node)

if path:
    print("Path found:", ' -> '.join(path))
else:
    print("No path found.")

# vert = 6; start=1 ; end=7
-----------------------------------------------------------------------------------------------------------------------------

# Depth-First Search algorithm
def dfs(graph, start, goal, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    if start == goal:
        return [start]
    for neighbor in graph[start]:
        if neighbor not in visited:
            path = dfs(graph, neighbor, goal, visited)
            if path:
                return [start] + path
    return []

# Example usage:
graph = {}
n = int(input("Enter the number of nodes: "))
print("Enter edges in the format 'node1 node2'")
for _ in range(n):
    node1, node2 = input().split()
    if node1 not in graph:
        graph[node1] = []
    if node2 not in graph:
        graph[node2] = []
    graph[node1].append(node2)
    graph[node2].append(node1)

start_node = input("Enter the start node: ")
goal_node = input("Enter the goal node: ")

print("\nStarting from", start_node)
print("Searching for", goal_node)

path = dfs(graph, start_node, goal_node)

if path:
    print("Path found:", ' -> '.join(path))
else:
    print("No path found.")

# vert = 6; start=1 ; end=7

-------------------------------------------------------------------------------------------
from queue import PriorityQueue

# Greedy Best-First Search algorithm
def gbfs(graph, start, goal, heuristic):
    open_list = PriorityQueue()
    open_list.put((heuristic[start], start))
    closed_set = set()

    while not open_list.empty():
        _, current_node = open_list.get()
        if current_node == goal:
            return True
        closed_set.add(current_node)
        for neighbor in graph[current_node]:
            if neighbor not in closed_set:
                open_list.put((heuristic[neighbor], neighbor))
    return False

# Example usage:
graph = {}
n = int(input("Enter the number of nodes: "))
print("Enter edges in the format 'node1 node2'")
for _ in range(n):
    node1, node2 = input().split()
    if node1 not in graph:
        graph[node1] = []
    if node2 not in graph:
        graph[node2] = []
    graph[node1].append(node2)
    graph[node2].append(node1)

start_node = input("Enter the start node: ")
goal_node = input("Enter the goal node: ")

# Define heuristic values for each node (you can replace this with your own)
heuristic = {}
print("Enter heuristic values for each node:")
for node in graph.keys():
    heuristic[node] = int(input("Heuristic value for node {}: ".format(node)))

print("\nStarting from", start_node)
print("Searching for", goal_node)

if gbfs(graph, start_node, goal_node, heuristic):
    print("Goal found:", goal_node)
else:
    print("Goal not found.")

# vert = 6; start=A ; end=F
# Hueristic = 8 6 5 4 3 0 1 
-----------------------------------------------------------------------------------------------------

import heapq

# A* algorithm
def astar(graph, start, goal, heuristic):
    open_list = [(0, start)]  # (f-value, node)
    closed_set = set()
    g_values = {node: float('inf') for node in graph}  # Initialize g-values to infinity
    g_values[start] = 0

    while open_list:
        _, current_node = heapq.heappop(open_list)
        if current_node == goal:
            return True
        closed_set.add(current_node)
        for neighbor, cost in graph[current_node].items():
            tentative_g = g_values[current_node] + cost
            if tentative_g < g_values[neighbor]:
                g_values[neighbor] = tentative_g
                f_value = tentative_g + heuristic[neighbor]
                heapq.heappush(open_list, (f_value, neighbor))
    return False

# Example usage:
graph = {}
n = int(input("Enter the number of nodes: "))
print("Enter edges in the format 'node1 node2 cost'")
for _ in range(n):
    node1, node2, cost = input().split()
    cost = int(cost)
    if node1 not in graph:
        graph[node1] = {}
    if node2 not in graph:
        graph[node2] = {}
    graph[node1][node2] = cost
    graph[node2][node1] = cost

start_node = input("Enter the start node: ")
goal_node = input("Enter the goal node: ")

# Define heuristic values for each node (you can replace this with your own)
heuristic = {}
print("Enter heuristic values for each node:")
for node in graph.keys():
    heuristic[node] = int(input("Heuristic value for node {}: ".format(node)))

print("\nStarting from", start_node)
print("Searching for", goal_node)

if astar(graph, start_node, goal_node, heuristic):
    print("Goal found:", goal_node)
else:
    print("Goal not found.")

# vert = 6; start=A ; end=F
# 3 2 4 5 7 1
# Hueristic = 8 6 5 4 3 0 1 

------------------------------------------------------------------------------------------------------------------------

import random

def objective_function(solution):
    # Define your objective function here
    # This function should evaluate the quality of a solution and return a value
    # The higher the value, the better the solution
    # Modify this function based on your specific optimization problem
    return sum(solution)

def generate_neighbor(current_solution):
    # Generate a neighboring solution by making a small modification to the current solution
    # This function should implement the logic to generate a neighboring solution
    # Modify this function based on your specific optimization problem
    neighbor = current_solution[:]
    index = random.randint(0, len(neighbor) - 1)
    neighbor[index] = 1 - neighbor[index]  # Flip the value at the selected index
    return neighbor

def hill_climbing():
    # Initialization
    current_solution = [random.randint(0, 1) for _ in range(10)]  # Generate an initial solution
    current_fitness = objective_function(current_solution)

    # Iterative process
    while True:
        # Neighbor generation
        neighbor = generate_neighbor(current_solution)
        neighbor_fitness = objective_function(neighbor)

        # Comparison
        if neighbor_fitness >= current_fitness:
            current_solution = neighbor
            current_fitness = neighbor_fitness
        else:
            break  # Terminate if no better solution is found

    return current_solution, current_fitness

# Usage example
best_solution, best_fitness = hill_climbing()
print("Best Solution:", best_solution)
print("Best Fitness:", best_fitness)
